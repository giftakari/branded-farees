# coding: utf-8

"""
    Akaris Travels Air

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 11.10.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from datetime import date

from pydantic import Field, StrictBool, StrictStr, constr, validator

from typing import Optional

from openapi_client.models.document_type_enum import DocumentTypeEnum
from openapi_client.models.identifier_type_enum import IdentifierTypeENUM
from openapi_client.models.reservation_detail_wrapper import ReservationDetailWrapper
from openapi_client.models.reservation_list_response_wrapper import ReservationListResponseWrapper
from openapi_client.models.reservation_query_build_wrapper import ReservationQueryBuildWrapper
from openapi_client.models.reservation_query_commit_reservation import ReservationQueryCommitReservation
from openapi_client.models.reservation_query_divide import ReservationQueryDivide
from openapi_client.models.reservation_query_search_criteria_reservation import ReservationQuerySearchCriteriaReservation
from openapi_client.models.reservation_response_wrapper import ReservationResponseWrapper

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class ReservationApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def build_reservation(self, reservation_query_build_wrapper : ReservationQueryBuildWrapper, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Single payload booking request  # noqa: E501

        As an alternative to the booking workflow that takes place in a workbench session, you can send all booking details and commit a single payload to create a booking. The single payload book request does not support any of the optional steps in the booking workflow, such as adding seats or ancillaries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.build_reservation(reservation_query_build_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_query_build_wrapper: (required)
        :type reservation_query_build_wrapper: ReservationQueryBuildWrapper
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the build_reservation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.build_reservation_with_http_info(reservation_query_build_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def build_reservation_with_http_info(self, reservation_query_build_wrapper : ReservationQueryBuildWrapper, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Single payload booking request  # noqa: E501

        As an alternative to the booking workflow that takes place in a workbench session, you can send all booking details and commit a single payload to create a booking. The single payload book request does not support any of the optional steps in the booking workflow, such as adding seats or ancillaries.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.build_reservation_with_http_info(reservation_query_build_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_query_build_wrapper: (required)
        :type reservation_query_build_wrapper: ReservationQueryBuildWrapper
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'reservation_query_build_wrapper',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method build_reservation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reservation_query_build_wrapper'] is not None:
            _body_params = _params['reservation_query_build_wrapper']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '201': "ReservationResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/build', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def cancel_reservation_offer(self, reservation_identifier : constr(strict=True, max_length=128), supplier_locator : Optional[constr(strict=True, max_length=32)] = None, offer_id : Optional[StrictStr] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Cancel an Offer within a Reservation  # noqa: E501

        Cancel an Offer by modifying the Reservation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_reservation_offer(reservation_identifier, supplier_locator, offer_id, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_identifier: (required)
        :type reservation_identifier: str
        :param supplier_locator:
        :type supplier_locator: str
        :param offer_id:
        :type offer_id: str
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the cancel_reservation_offer_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.cancel_reservation_offer_with_http_info(reservation_identifier, supplier_locator, offer_id, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def cancel_reservation_offer_with_http_info(self, reservation_identifier : constr(strict=True, max_length=128), supplier_locator : Optional[constr(strict=True, max_length=32)] = None, offer_id : Optional[StrictStr] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Cancel an Offer within a Reservation  # noqa: E501

        Cancel an Offer by modifying the Reservation  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.cancel_reservation_offer_with_http_info(reservation_identifier, supplier_locator, offer_id, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_identifier: (required)
        :type reservation_identifier: str
        :param supplier_locator:
        :type supplier_locator: str
        :param offer_id:
        :type offer_id: str
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'reservation_identifier',
            'supplier_locator',
            'offer_id',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method cancel_reservation_offer" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['reservation_identifier']:
            _path_params['reservationIdentifier'] = _params['reservation_identifier']


        # process the query parameters
        _query_params = []
        if _params.get('supplier_locator') is not None:  # noqa: E501
            _query_params.append(('supplierLocator', _params['supplier_locator']))

        if _params.get('offer_id') is not None:  # noqa: E501
            _query_params.append(('offerID', _params['offer_id']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/{reservationIdentifier}/canceloffer', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def commit_reservation(self, identifier : Annotated[constr(strict=True, max_length=128), Field(..., description="Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database.")], auto_delete_date : Annotated[Optional[date], Field(description="Acts as a retention segment to hold the reservation open past the last date of travel purge date. Sending a new autoDeleteDate at commit step will update the existing autoDeleteDate. Sending 000/00/00 will delete an existing autoDeleteDate.")] = None, issuance : Annotated[Optional[StrictStr], Field(description="Indicates the type of issuance that should be performed at commit. (Ticket, BackOffice (MIR/TAIR))")] = None, document_value : Annotated[Optional[StrictStr], Field(description="Indicates of the value of the document should be refunded or retained following a CancelOffer action")] = None, pay_later_ind : Annotated[Optional[StrictBool], Field(description="If true, the Reservation will be fulfilled at a later date")] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, reservation_query_commit_reservation : Optional[ReservationQueryCommitReservation] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Commit workbench  # noqa: E501

        After all required and any optional steps in a booking workbench session, send a POST request with the workbench identifier to commit the workbench. The resulting actions depend on whether payment is present in the workbench. If no Add Payment request has been sent, committing the workbench books the itinerary and generates a PNR. If an Add Payment request has not been sent, committing the workbench tickets the itinerary and generates ticket number/s.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.commit_reservation(identifier, auto_delete_date, issuance, document_value, pay_later_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, reservation_query_commit_reservation, async_req=True)
        >>> result = thread.get()

        :param identifier: Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database. (required)
        :type identifier: str
        :param auto_delete_date: Acts as a retention segment to hold the reservation open past the last date of travel purge date. Sending a new autoDeleteDate at commit step will update the existing autoDeleteDate. Sending 000/00/00 will delete an existing autoDeleteDate.
        :type auto_delete_date: date
        :param issuance: Indicates the type of issuance that should be performed at commit. (Ticket, BackOffice (MIR/TAIR))
        :type issuance: str
        :param document_value: Indicates of the value of the document should be refunded or retained following a CancelOffer action
        :type document_value: str
        :param pay_later_ind: If true, the Reservation will be fulfilled at a later date
        :type pay_later_ind: bool
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param reservation_query_commit_reservation:
        :type reservation_query_commit_reservation: ReservationQueryCommitReservation
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the commit_reservation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.commit_reservation_with_http_info(identifier, auto_delete_date, issuance, document_value, pay_later_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, reservation_query_commit_reservation, **kwargs)  # noqa: E501

    @validate_arguments
    def commit_reservation_with_http_info(self, identifier : Annotated[constr(strict=True, max_length=128), Field(..., description="Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database.")], auto_delete_date : Annotated[Optional[date], Field(description="Acts as a retention segment to hold the reservation open past the last date of travel purge date. Sending a new autoDeleteDate at commit step will update the existing autoDeleteDate. Sending 000/00/00 will delete an existing autoDeleteDate.")] = None, issuance : Annotated[Optional[StrictStr], Field(description="Indicates the type of issuance that should be performed at commit. (Ticket, BackOffice (MIR/TAIR))")] = None, document_value : Annotated[Optional[StrictStr], Field(description="Indicates of the value of the document should be refunded or retained following a CancelOffer action")] = None, pay_later_ind : Annotated[Optional[StrictBool], Field(description="If true, the Reservation will be fulfilled at a later date")] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, reservation_query_commit_reservation : Optional[ReservationQueryCommitReservation] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Commit workbench  # noqa: E501

        After all required and any optional steps in a booking workbench session, send a POST request with the workbench identifier to commit the workbench. The resulting actions depend on whether payment is present in the workbench. If no Add Payment request has been sent, committing the workbench books the itinerary and generates a PNR. If an Add Payment request has not been sent, committing the workbench tickets the itinerary and generates ticket number/s.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.commit_reservation_with_http_info(identifier, auto_delete_date, issuance, document_value, pay_later_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, reservation_query_commit_reservation, async_req=True)
        >>> result = thread.get()

        :param identifier: Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database. (required)
        :type identifier: str
        :param auto_delete_date: Acts as a retention segment to hold the reservation open past the last date of travel purge date. Sending a new autoDeleteDate at commit step will update the existing autoDeleteDate. Sending 000/00/00 will delete an existing autoDeleteDate.
        :type auto_delete_date: date
        :param issuance: Indicates the type of issuance that should be performed at commit. (Ticket, BackOffice (MIR/TAIR))
        :type issuance: str
        :param document_value: Indicates of the value of the document should be refunded or retained following a CancelOffer action
        :type document_value: str
        :param pay_later_ind: If true, the Reservation will be fulfilled at a later date
        :type pay_later_ind: bool
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param reservation_query_commit_reservation:
        :type reservation_query_commit_reservation: ReservationQueryCommitReservation
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identifier',
            'auto_delete_date',
            'issuance',
            'document_value',
            'pay_later_ind',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id',
            'reservation_query_commit_reservation'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method commit_reservation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identifier']:
            _path_params['Identifier'] = _params['identifier']


        # process the query parameters
        _query_params = []
        if _params.get('auto_delete_date') is not None:  # noqa: E501
            if isinstance(_params['auto_delete_date'], date):
                _query_params.append(('autoDeleteDate', _params['auto_delete_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('autoDeleteDate', _params['auto_delete_date']))

        if _params.get('issuance') is not None:  # noqa: E501
            _query_params.append(('Issuance', _params['issuance']))

        if _params.get('document_value') is not None:  # noqa: E501
            _query_params.append(('DocumentValue', _params['document_value']))

        if _params.get('pay_later_ind') is not None:  # noqa: E501
            _query_params.append(('payLaterInd', _params['pay_later_ind']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reservation_query_commit_reservation'] is not None:
            _body_params = _params['reservation_query_commit_reservation']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationResponseWrapper",
            '201': "ReservationResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/{Identifier}', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def create_reservation(self, reservation_detail_wrapper : ReservationDetailWrapper, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Create a reservation  # noqa: E501

        Create a reservation on the core or with the vendor/provider.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_reservation(reservation_detail_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_detail_wrapper: (required)
        :type reservation_detail_wrapper: ReservationDetailWrapper
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the create_reservation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.create_reservation_with_http_info(reservation_detail_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def create_reservation_with_http_info(self, reservation_detail_wrapper : ReservationDetailWrapper, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Create a reservation  # noqa: E501

        Create a reservation on the core or with the vendor/provider.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.create_reservation_with_http_info(reservation_detail_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_detail_wrapper: (required)
        :type reservation_detail_wrapper: ReservationDetailWrapper
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'reservation_detail_wrapper',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_reservation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reservation_detail_wrapper'] is not None:
            _body_params = _params['reservation_detail_wrapper']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationResponseWrapper",
            '201': "ReservationResponseWrapper",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def divide(self, reservation_query_divide : ReservationQueryDivide, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationListResponseWrapper:  # noqa: E501
        """Divide a reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.divide(reservation_query_divide, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_query_divide: (required)
        :type reservation_query_divide: ReservationQueryDivide
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationListResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the divide_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.divide_with_http_info(reservation_query_divide, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def divide_with_http_info(self, reservation_query_divide : ReservationQueryDivide, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Divide a reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.divide_with_http_info(reservation_query_divide, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_query_divide: (required)
        :type reservation_query_divide: ReservationQueryDivide
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationListResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'reservation_query_divide',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method divide" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reservation_query_divide'] is not None:
            _body_params = _params['reservation_query_divide']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationListResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/divide', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def find_reservation(self, reservation_query_search_criteria_reservation : ReservationQuerySearchCriteriaReservation, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationListResponseWrapper:  # noqa: E501
        """Find a reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_reservation(reservation_query_search_criteria_reservation, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_query_search_criteria_reservation: (required)
        :type reservation_query_search_criteria_reservation: ReservationQuerySearchCriteriaReservation
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationListResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the find_reservation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.find_reservation_with_http_info(reservation_query_search_criteria_reservation, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def find_reservation_with_http_info(self, reservation_query_search_criteria_reservation : ReservationQuerySearchCriteriaReservation, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Find a reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.find_reservation_with_http_info(reservation_query_search_criteria_reservation, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param reservation_query_search_criteria_reservation: (required)
        :type reservation_query_search_criteria_reservation: ReservationQuerySearchCriteriaReservation
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationListResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'reservation_query_search_criteria_reservation',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method find_reservation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reservation_query_search_criteria_reservation'] is not None:
            _body_params = _params['reservation_query_search_criteria_reservation']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '201': "ReservationListResponseWrapper",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/find', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def get_reservation_by_locator(self, locator : Optional[constr(strict=True, max_length=16)] = None, creation_date : Annotated[Optional[date], Field(description="PNR creation Date")] = None, detail_view_ind : Annotated[Optional[StrictBool], Field(description="If true, ReservationDetail will be returned")] = None, view_brand_complete_info_ind : Annotated[Optional[StrictBool], Field(description="If true, Brand complete information will be returned in Reservation Response")] = None, view_baggage_detail_ind : Annotated[Optional[StrictBool], Field(description="if true, full baggage information will be returned in Reservation Response")] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Retrieve a reservation by locator  # noqa: E501

        To be deprecated and replaced by Get by Identifier using identifier Type \"Locator\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reservation_by_locator(locator, creation_date, detail_view_ind, view_brand_complete_info_ind, view_baggage_detail_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param locator:
        :type locator: str
        :param creation_date: PNR creation Date
        :type creation_date: date
        :param detail_view_ind: If true, ReservationDetail will be returned
        :type detail_view_ind: bool
        :param view_brand_complete_info_ind: If true, Brand complete information will be returned in Reservation Response
        :type view_brand_complete_info_ind: bool
        :param view_baggage_detail_ind: if true, full baggage information will be returned in Reservation Response
        :type view_baggage_detail_ind: bool
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the get_reservation_by_locator_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.get_reservation_by_locator_with_http_info(locator, creation_date, detail_view_ind, view_brand_complete_info_ind, view_baggage_detail_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def get_reservation_by_locator_with_http_info(self, locator : Optional[constr(strict=True, max_length=16)] = None, creation_date : Annotated[Optional[date], Field(description="PNR creation Date")] = None, detail_view_ind : Annotated[Optional[StrictBool], Field(description="If true, ReservationDetail will be returned")] = None, view_brand_complete_info_ind : Annotated[Optional[StrictBool], Field(description="If true, Brand complete information will be returned in Reservation Response")] = None, view_baggage_detail_ind : Annotated[Optional[StrictBool], Field(description="if true, full baggage information will be returned in Reservation Response")] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve a reservation by locator  # noqa: E501

        To be deprecated and replaced by Get by Identifier using identifier Type \"Locator\"  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.get_reservation_by_locator_with_http_info(locator, creation_date, detail_view_ind, view_brand_complete_info_ind, view_baggage_detail_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param locator:
        :type locator: str
        :param creation_date: PNR creation Date
        :type creation_date: date
        :param detail_view_ind: If true, ReservationDetail will be returned
        :type detail_view_ind: bool
        :param view_brand_complete_info_ind: If true, Brand complete information will be returned in Reservation Response
        :type view_brand_complete_info_ind: bool
        :param view_baggage_detail_ind: if true, full baggage information will be returned in Reservation Response
        :type view_baggage_detail_ind: bool
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'locator',
            'creation_date',
            'detail_view_ind',
            'view_brand_complete_info_ind',
            'view_baggage_detail_ind',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_reservation_by_locator" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('locator') is not None:  # noqa: E501
            _query_params.append(('Locator', _params['locator']))

        if _params.get('creation_date') is not None:  # noqa: E501
            if isinstance(_params['creation_date'], date):
                _query_params.append(('creationDate', _params['creation_date'].strftime(self.api_client.configuration.date_format)))
            else:
                _query_params.append(('creationDate', _params['creation_date']))

        if _params.get('detail_view_ind') is not None:  # noqa: E501
            _query_params.append(('detailViewInd', _params['detail_view_ind']))

        if _params.get('view_brand_complete_info_ind') is not None:  # noqa: E501
            _query_params.append(('viewBrandCompleteInfoInd', _params['view_brand_complete_info_ind']))

        if _params.get('view_baggage_detail_ind') is not None:  # noqa: E501
            _query_params.append(('viewBaggageDetailInd', _params['view_baggage_detail_ind']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/getbylocator', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def retrieve_reservation(self, identifier : Annotated[constr(strict=True, max_length=128), Field(..., description="Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database.")], authority : Annotated[constr(strict=True, max_length=128), Field(..., description="The authorising entity creating the identifier")], detail_view_ind : Annotated[Optional[StrictBool], Field(description="If true, ReservationDetail will be returned.")] = None, view_brand_complete_info_ind : Annotated[Optional[StrictBool], Field(description="If true, Brand complete information will be returned in Reservation Response")] = None, view_baggage_detail_ind : Annotated[Optional[StrictBool], Field(description="if true, full baggage information will be returned in Reservation Response")] = None, identifier_type : Annotated[Optional[IdentifierTypeENUM], Field(description="The type of identifier key used to retrieve the reservation")] = None, document_type : Annotated[Optional[DocumentTypeEnum], Field(description="When document is selected in IdentifierType, use documentType to identify the type of document")] = None, view_shopping_cart_products_ind : Annotated[Optional[StrictBool], Field(description="If true, Unfinished Offers will be returned as ShoppingCartProducts")] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Retrieve a Reservation  # noqa: E501

        Retrieve details about a held booking, or PNR. While a PNR refers to a held booking that has not been ticketed, the PNR code persists after ticketing to provide the booking records. Once a PNR has been ticketed, you can still use PNR Retrieve to return both booking and ticketing details. A Ticket Display request can also be used to retrieve any ticketed itinerary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.retrieve_reservation(identifier, authority, detail_view_ind, view_brand_complete_info_ind, view_baggage_detail_ind, identifier_type, document_type, view_shopping_cart_products_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param identifier: Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database. (required)
        :type identifier: str
        :param authority: The authorising entity creating the identifier (required)
        :type authority: str
        :param detail_view_ind: If true, ReservationDetail will be returned.
        :type detail_view_ind: bool
        :param view_brand_complete_info_ind: If true, Brand complete information will be returned in Reservation Response
        :type view_brand_complete_info_ind: bool
        :param view_baggage_detail_ind: if true, full baggage information will be returned in Reservation Response
        :type view_baggage_detail_ind: bool
        :param identifier_type: The type of identifier key used to retrieve the reservation
        :type identifier_type: IdentifierTypeENUM
        :param document_type: When document is selected in IdentifierType, use documentType to identify the type of document
        :type document_type: DocumentTypeEnum
        :param view_shopping_cart_products_ind: If true, Unfinished Offers will be returned as ShoppingCartProducts
        :type view_shopping_cart_products_ind: bool
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the retrieve_reservation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.retrieve_reservation_with_http_info(identifier, authority, detail_view_ind, view_brand_complete_info_ind, view_baggage_detail_ind, identifier_type, document_type, view_shopping_cart_products_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def retrieve_reservation_with_http_info(self, identifier : Annotated[constr(strict=True, max_length=128), Field(..., description="Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database.")], authority : Annotated[constr(strict=True, max_length=128), Field(..., description="The authorising entity creating the identifier")], detail_view_ind : Annotated[Optional[StrictBool], Field(description="If true, ReservationDetail will be returned.")] = None, view_brand_complete_info_ind : Annotated[Optional[StrictBool], Field(description="If true, Brand complete information will be returned in Reservation Response")] = None, view_baggage_detail_ind : Annotated[Optional[StrictBool], Field(description="if true, full baggage information will be returned in Reservation Response")] = None, identifier_type : Annotated[Optional[IdentifierTypeENUM], Field(description="The type of identifier key used to retrieve the reservation")] = None, document_type : Annotated[Optional[DocumentTypeEnum], Field(description="When document is selected in IdentifierType, use documentType to identify the type of document")] = None, view_shopping_cart_products_ind : Annotated[Optional[StrictBool], Field(description="If true, Unfinished Offers will be returned as ShoppingCartProducts")] = None, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Retrieve a Reservation  # noqa: E501

        Retrieve details about a held booking, or PNR. While a PNR refers to a held booking that has not been ticketed, the PNR code persists after ticketing to provide the booking records. Once a PNR has been ticketed, you can still use PNR Retrieve to return both booking and ticketing details. A Ticket Display request can also be used to retrieve any ticketed itinerary.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.retrieve_reservation_with_http_info(identifier, authority, detail_view_ind, view_brand_complete_info_ind, view_baggage_detail_ind, identifier_type, document_type, view_shopping_cart_products_ind, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param identifier: Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database. (required)
        :type identifier: str
        :param authority: The authorising entity creating the identifier (required)
        :type authority: str
        :param detail_view_ind: If true, ReservationDetail will be returned.
        :type detail_view_ind: bool
        :param view_brand_complete_info_ind: If true, Brand complete information will be returned in Reservation Response
        :type view_brand_complete_info_ind: bool
        :param view_baggage_detail_ind: if true, full baggage information will be returned in Reservation Response
        :type view_baggage_detail_ind: bool
        :param identifier_type: The type of identifier key used to retrieve the reservation
        :type identifier_type: IdentifierTypeENUM
        :param document_type: When document is selected in IdentifierType, use documentType to identify the type of document
        :type document_type: DocumentTypeEnum
        :param view_shopping_cart_products_ind: If true, Unfinished Offers will be returned as ShoppingCartProducts
        :type view_shopping_cart_products_ind: bool
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identifier',
            'authority',
            'detail_view_ind',
            'view_brand_complete_info_ind',
            'view_baggage_detail_ind',
            'identifier_type',
            'document_type',
            'view_shopping_cart_products_ind',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method retrieve_reservation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identifier']:
            _path_params['Identifier'] = _params['identifier']


        # process the query parameters
        _query_params = []
        if _params.get('authority') is not None:  # noqa: E501
            _query_params.append(('authority', _params['authority']))

        if _params.get('detail_view_ind') is not None:  # noqa: E501
            _query_params.append(('detailViewInd', _params['detail_view_ind']))

        if _params.get('view_brand_complete_info_ind') is not None:  # noqa: E501
            _query_params.append(('viewBrandCompleteInfoInd', _params['view_brand_complete_info_ind']))

        if _params.get('view_baggage_detail_ind') is not None:  # noqa: E501
            _query_params.append(('viewBaggageDetailInd', _params['view_baggage_detail_ind']))

        if _params.get('identifier_type') is not None:  # noqa: E501
            _query_params.append(('identifierType', _params['identifier_type'].value))

        if _params.get('document_type') is not None:  # noqa: E501
            _query_params.append(('documentType', _params['document_type'].value))

        if _params.get('view_shopping_cart_products_ind') is not None:  # noqa: E501
            _query_params.append(('viewShoppingCartProductsInd', _params['view_shopping_cart_products_ind']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/{Identifier}', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def update_reservation(self, identifier : Annotated[constr(strict=True, max_length=128), Field(..., description="Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database.")], reservation_detail_wrapper : ReservationDetailWrapper, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ReservationResponseWrapper:  # noqa: E501
        """Update a reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_reservation(identifier, reservation_detail_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param identifier: Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database. (required)
        :type identifier: str
        :param reservation_detail_wrapper: (required)
        :type reservation_detail_wrapper: ReservationDetailWrapper
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: ReservationResponseWrapper
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the update_reservation_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.update_reservation_with_http_info(identifier, reservation_detail_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, **kwargs)  # noqa: E501

    @validate_arguments
    def update_reservation_with_http_info(self, identifier : Annotated[constr(strict=True, max_length=128), Field(..., description="Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database.")], reservation_detail_wrapper : ReservationDetailWrapper, trace_id : Annotated[Optional[StrictStr], Field(description="Identifier used to correlate API invocations across long-running or multi-call business flows.")] = None, xauth_travelport_accessgroup : Annotated[Optional[StrictStr], Field(description="Identifies the Travelport access group with which the caller is associated")] = None, travelport_plus_session_id : Annotated[Optional[StrictStr], Field(description="Travelport Plus Session ID used to maintain an established agency session")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Update a reservation  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.update_reservation_with_http_info(identifier, reservation_detail_wrapper, trace_id, xauth_travelport_accessgroup, travelport_plus_session_id, async_req=True)
        >>> result = thread.get()

        :param identifier: Identifier provides the ability to create a globally unique identifier. For the identifier to be globally unique it must have a system provided identifier and the system must be identified using a global naming authority. System identification uses the domain naming system (DNS) to assure they are globally unique and should be an URL. The system provided ID will typically be a primary or surrogate key in a database. (required)
        :type identifier: str
        :param reservation_detail_wrapper: (required)
        :type reservation_detail_wrapper: ReservationDetailWrapper
        :param trace_id: Identifier used to correlate API invocations across long-running or multi-call business flows.
        :type trace_id: str
        :param xauth_travelport_accessgroup: Identifies the Travelport access group with which the caller is associated
        :type xauth_travelport_accessgroup: str
        :param travelport_plus_session_id: Travelport Plus Session ID used to maintain an established agency session
        :type travelport_plus_session_id: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(ReservationResponseWrapper, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'identifier',
            'reservation_detail_wrapper',
            'trace_id',
            'xauth_travelport_accessgroup',
            'travelport_plus_session_id'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method update_reservation" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}
        if _params['identifier']:
            _path_params['Identifier'] = _params['identifier']


        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        if _params['trace_id']:
            _header_params['TraceId'] = _params['trace_id']

        if _params['xauth_travelport_accessgroup']:
            _header_params['XAUTH_TRAVELPORT_ACCESSGROUP'] = _params['xauth_travelport_accessgroup']

        if _params['travelport_plus_session_id']:
            _header_params['TravelportPlusSessionID'] = _params['travelport_plus_session_id']

        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['reservation_detail_wrapper'] is not None:
            _body_params = _params['reservation_detail_wrapper']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = ['OAuth2']  # noqa: E501

        _response_types_map = {
            '200': "ReservationResponseWrapper",
            '400': "ErrorResponse",
            '401': "ErrorResponse",
            '402': "ErrorResponse",
            '403': "ErrorResponse",
            '404': "ErrorResponse",
            '500': "ErrorResponse",
        }

        return self.api_client.call_api(
            '/book/reservation/reservations/{Identifier}', 'PUT',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
