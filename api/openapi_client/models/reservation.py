# coding: utf-8

"""
    Akaris Travels Air

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 11.10.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from datetime import date
from typing import List, Optional, Union
from pydantic import Field, conlist, constr
from openapi_client.models.agency_service_fee import AgencyServiceFee
from openapi_client.models.form_of_payment_id import FormOfPaymentID
from openapi_client.models.identifier import Identifier
from openapi_client.models.offer import Offer
from openapi_client.models.offer_link import OfferLink
from openapi_client.models.organization_loyalty_program import OrganizationLoyaltyProgram
from openapi_client.models.payment import Payment
from openapi_client.models.preference import Preference
from openapi_client.models.primary_contact import PrimaryContact
from openapi_client.models.receipt import Receipt
from openapi_client.models.reservation_comment import ReservationComment
from openapi_client.models.reservation_display_sequence import ReservationDisplaySequence
from openapi_client.models.reservation_id import ReservationID
from openapi_client.models.shopping_cart import ShoppingCart
from openapi_client.models.special_service import SpecialService
from openapi_client.models.travel_agency import TravelAgency
from openapi_client.models.traveler import Traveler
from openapi_client.models.traveler_product import TravelerProduct

class Reservation(ReservationID):
    """
    Reservation
    """
    offer: Optional[conlist(Offer, max_items=100)] = Field(None, alias="Offer")
    traveler: Optional[conlist(Traveler, max_items=300)] = Field(None, alias="Traveler")
    traveler_product: Optional[conlist(TravelerProduct, max_items=3000)] = Field(None, alias="TravelerProduct")
    form_of_payment: Optional[conlist(FormOfPaymentID, max_items=100)] = Field(None, alias="FormOfPayment")
    payment: Optional[conlist(Payment, max_items=100)] = Field(None, alias="Payment")
    receipt: Optional[conlist(Receipt, max_items=1000)] = Field(None, alias="Receipt")
    offer_link: Optional[conlist(OfferLink)] = Field(None, alias="OfferLink")
    reservation_comment: Optional[conlist(ReservationComment, max_items=1000)] = Field(None, alias="ReservationComment")
    primary_contact: Optional[conlist(PrimaryContact, max_items=10)] = Field(None, alias="PrimaryContact")
    travel_agency: Optional[TravelAgency] = Field(None, alias="TravelAgency")
    group_name: Optional[constr(strict=True, max_length=64)] = Field(None, alias="GroupName", description="A name assigned to a Reservation containing an offer with Passengerflight/Flight Quantity equal to or greater than 10")
    special_service: Optional[conlist(SpecialService)] = Field(None, alias="SpecialService")
    preference: Optional[Preference] = Field(None, alias="Preference")
    organization_loyalty_program: Optional[conlist(OrganizationLoyaltyProgram, max_items=10)] = Field(None, alias="OrganizationLoyaltyProgram")
    shopping_cart: Optional[ShoppingCart] = Field(None, alias="ShoppingCart")
    reservation_display_sequence: Optional[ReservationDisplaySequence] = Field(None, alias="ReservationDisplaySequence")
    agency_service_fee: Optional[conlist(AgencyServiceFee, max_items=100)] = Field(None, alias="AgencyServiceFee")
    auto_delete_date: Optional[date] = Field(None, alias="autoDeleteDate", description="The auto delete date represents the date that the Reservation will be kept active. Also known as retention segment or retention date.")
    notification_date: Optional[date] = Field(None, alias="notificationDate", description="The notification date represents the date that the Reservation should be reviewed. Also known as ticket time limit date.")
    __properties = ["@type", "id", "Identifier", "Offer", "Traveler", "TravelerProduct", "FormOfPayment", "Payment", "Receipt", "OfferLink", "ReservationComment", "PrimaryContact", "TravelAgency", "GroupName", "SpecialService", "Preference", "OrganizationLoyaltyProgram", "ShoppingCart", "ReservationDisplaySequence", "AgencyServiceFee", "autoDeleteDate", "notificationDate"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    # JSON field name that stores the object type
    __discriminator_property_name = '@type'

    # discriminator mappings
    __discriminator_value_class_map = {
        'ReservationDetail': 'ReservationDetail'
    }

    @classmethod
    def get_discriminator_value(cls, obj: dict) -> str:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Union(ReservationDetail):
        """Create an instance of Reservation from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of identifier
        if self.identifier:
            _dict['Identifier'] = self.identifier.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in offer (list)
        _items = []
        if self.offer:
            for _item in self.offer:
                if _item:
                    _items.append(_item.to_dict())
            _dict['Offer'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in traveler (list)
        _items = []
        if self.traveler:
            for _item in self.traveler:
                if _item:
                    _items.append(_item.to_dict())
            _dict['Traveler'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in traveler_product (list)
        _items = []
        if self.traveler_product:
            for _item in self.traveler_product:
                if _item:
                    _items.append(_item.to_dict())
            _dict['TravelerProduct'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in form_of_payment (list)
        _items = []
        if self.form_of_payment:
            for _item in self.form_of_payment:
                if _item:
                    _items.append(_item.to_dict())
            _dict['FormOfPayment'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in payment (list)
        _items = []
        if self.payment:
            for _item in self.payment:
                if _item:
                    _items.append(_item.to_dict())
            _dict['Payment'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in receipt (list)
        _items = []
        if self.receipt:
            for _item in self.receipt:
                if _item:
                    _items.append(_item.to_dict())
            _dict['Receipt'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in offer_link (list)
        _items = []
        if self.offer_link:
            for _item in self.offer_link:
                if _item:
                    _items.append(_item.to_dict())
            _dict['OfferLink'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in reservation_comment (list)
        _items = []
        if self.reservation_comment:
            for _item in self.reservation_comment:
                if _item:
                    _items.append(_item.to_dict())
            _dict['ReservationComment'] = _items
        # override the default output from pydantic by calling `to_dict()` of each item in primary_contact (list)
        _items = []
        if self.primary_contact:
            for _item in self.primary_contact:
                if _item:
                    _items.append(_item.to_dict())
            _dict['PrimaryContact'] = _items
        # override the default output from pydantic by calling `to_dict()` of travel_agency
        if self.travel_agency:
            _dict['TravelAgency'] = self.travel_agency.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in special_service (list)
        _items = []
        if self.special_service:
            for _item in self.special_service:
                if _item:
                    _items.append(_item.to_dict())
            _dict['SpecialService'] = _items
        # override the default output from pydantic by calling `to_dict()` of preference
        if self.preference:
            _dict['Preference'] = self.preference.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in organization_loyalty_program (list)
        _items = []
        if self.organization_loyalty_program:
            for _item in self.organization_loyalty_program:
                if _item:
                    _items.append(_item.to_dict())
            _dict['OrganizationLoyaltyProgram'] = _items
        # override the default output from pydantic by calling `to_dict()` of shopping_cart
        if self.shopping_cart:
            _dict['ShoppingCart'] = self.shopping_cart.to_dict()
        # override the default output from pydantic by calling `to_dict()` of reservation_display_sequence
        if self.reservation_display_sequence:
            _dict['ReservationDisplaySequence'] = self.reservation_display_sequence.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in agency_service_fee (list)
        _items = []
        if self.agency_service_fee:
            for _item in self.agency_service_fee:
                if _item:
                    _items.append(_item.to_dict())
            _dict['AgencyServiceFee'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Union(ReservationDetail):
        """Create an instance of Reservation from a dict"""
        # look up the object type based on discriminator mapping
        object_type = cls.get_discriminator_value(obj)
        if object_type:
            klass = globals()[object_type]
            return klass.from_dict(obj)
        else:
            raise ValueError("Reservation failed to lookup discriminator value from " +
                             json.dumps(obj) + ". Discriminator property name: " + cls.__discriminator_property_name +
                             ", mapping: " + json.dumps(cls.__discriminator_value_class_map))

from openapi_client.models.reservation_detail import ReservationDetail
Reservation.update_forward_refs()

