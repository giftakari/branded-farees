# coding: utf-8

"""
    Akaris Travels Air

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 11.10.4
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import List, Optional
from pydantic import Field, StrictBool, StrictInt, StrictStr, conlist
from openapi_client.models.additional_details import AdditionalDetails
from openapi_client.models.room_amenity import RoomAmenity
from openapi_client.models.room_characteristics import RoomCharacteristics
from openapi_client.models.room_occupancy import RoomOccupancy
from openapi_client.models.room_type import RoomType
from openapi_client.models.text_title_and_description import TextTitleAndDescription

class RoomTypeDetail(RoomType):
    """
    RoomTypeDetail
    """
    number_of_units: Optional[StrictInt] = Field(None, alias="numberOfUnits", description="The number of rooms that have been combined to create this room type.")
    reqd_guarantee_type: Optional[StrictStr] = Field(None, alias="reqdGuaranteeType", description="TODO-(Should this be Guarantee?)Denotes the form of guarantee for this room.")
    additional_details: Optional[AdditionalDetails] = Field(None, alias="AdditionalDetails")
    room_occupancy: Optional[conlist(RoomOccupancy, max_items=10)] = Field(None, alias="RoomOccupancy")
    room_ind: Optional[StrictBool] = Field(None, alias="roomInd", description="Indicates the room is a sleeping room when true.")
    converted_ind: Optional[StrictBool] = Field(None, alias="convertedInd", description="Indicates the room is converted when true.")
    alternate_ind: Optional[StrictBool] = Field(None, alias="alternateInd", description="Indicates the room is an alternate room type to the requested room type when true.")
    __properties = ["@type", "RoomCharacteristics", "Description", "RoomAmenity", "numberOfUnits", "reqdGuaranteeType", "AdditionalDetails", "RoomOccupancy", "roomInd", "convertedInd", "alternateInd"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> RoomTypeDetail:
        """Create an instance of RoomTypeDetail from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of room_characteristics
        if self.room_characteristics:
            _dict['RoomCharacteristics'] = self.room_characteristics.to_dict()
        # override the default output from pydantic by calling `to_dict()` of description
        if self.description:
            _dict['Description'] = self.description.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in room_amenity (list)
        _items = []
        if self.room_amenity:
            for _item in self.room_amenity:
                if _item:
                    _items.append(_item.to_dict())
            _dict['RoomAmenity'] = _items
        # override the default output from pydantic by calling `to_dict()` of additional_details
        if self.additional_details:
            _dict['AdditionalDetails'] = self.additional_details.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in room_occupancy (list)
        _items = []
        if self.room_occupancy:
            for _item in self.room_occupancy:
                if _item:
                    _items.append(_item.to_dict())
            _dict['RoomOccupancy'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> RoomTypeDetail:
        """Create an instance of RoomTypeDetail from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return RoomTypeDetail.parse_obj(obj)

        _obj = RoomTypeDetail.parse_obj({
            "type": obj.get("@type"),
            "room_characteristics": RoomCharacteristics.from_dict(obj.get("RoomCharacteristics")) if obj.get("RoomCharacteristics") is not None else None,
            "description": TextTitleAndDescription.from_dict(obj.get("Description")) if obj.get("Description") is not None else None,
            "room_amenity": [RoomAmenity.from_dict(_item) for _item in obj.get("RoomAmenity")] if obj.get("RoomAmenity") is not None else None,
            "number_of_units": obj.get("numberOfUnits"),
            "reqd_guarantee_type": obj.get("reqdGuaranteeType"),
            "additional_details": AdditionalDetails.from_dict(obj.get("AdditionalDetails")) if obj.get("AdditionalDetails") is not None else None,
            "room_occupancy": [RoomOccupancy.from_dict(_item) for _item in obj.get("RoomOccupancy")] if obj.get("RoomOccupancy") is not None else None,
            "room_ind": obj.get("roomInd"),
            "converted_ind": obj.get("convertedInd"),
            "alternate_ind": obj.get("alternateInd")
        })
        return _obj


